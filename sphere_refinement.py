'''
Refine the Octahedron into higher and higher number of faces
'''
import struct
import random
import os

def read_stl(f_name):
    '''
    Read the Binary STLs and return a list of points and faces.
    General Binary STL is structured as:
    |{header} - 80 Bytes
    |{#Triangles} - 4 Bytes
    |{Triangle Vertex #1} - 12 Bytes
    |{Triangle Vertex #2} - 12 Bytes
    |{Triangle Vertex #3} - 12 Bytes
    |{Random Stuff} - 2 Bytes
    size = 84 + 50 * (#triangles) Bytes
    Return output is structured as:
    Points -> A list of vertex coordinates
        A list [[x1,y1,z1], [x2,y2,z2], ...]
    Faces  -> A list of vertex referencces
        A list [[p1_id, p2_id, p3_id], ...]
    '''
    normals = []
    tria_verts = []
    header = ''
    num_trias = 0
    with open(f_name, 'rb') as bin_stl:
        header = bin_stl.read(80)
        bin_stl.read(4)

        while True:
            tria_deets = bin_stl.read(50)
            if tria_deets:
                num_trias += 1
                norm_comps = []
                norm_comps.append(struct.unpack('<f', tria_deets[:4])[0])
                norm_comps.append(struct.unpack('<f', tria_deets[4:8])[0])
                norm_comps.append(struct.unpack('<f', tria_deets[8:12])[0])
                normals.append(norm_comps)

                tria = []

                verts = []
                verts.append(struct.unpack('<f', tria_deets[12:16])[0])
                verts.append(struct.unpack('<f', tria_deets[16:20])[0])
                verts.append(struct.unpack('<f', tria_deets[20:24])[0])
                tria.append(unit_vec(verts))

                verts = []
                verts.append(struct.unpack('<f', tria_deets[24:28])[0])
                verts.append(struct.unpack('<f', tria_deets[28:32])[0])
                verts.append(struct.unpack('<f', tria_deets[32:36])[0])
                tria.append(unit_vec(verts))

                verts = []
                verts.append(struct.unpack('<f', tria_deets[36:40])[0])
                verts.append(struct.unpack('<f', tria_deets[40:44])[0])
                verts.append(struct.unpack('<f', tria_deets[44:48])[0])
                tria.append(unit_vec(verts))

                tria_verts.append(tria)
            else:
                break

    return tria_verts

def save_stl(file_name, faces):
    '''
    Store the generated file as a new STL File.
    '''
    facet_count = len(faces)
    title_str = 'Generated by Vihang\'s STL Converter'
    with open(file_name, 'w',encoding="utf8") as f:
        f.write(title_str)
    empty = b'\x51'
    with open(file_name, 'ab') as bin_stl:
        #header
        # f.write(title_str)
        bin_stl.write(empty * (79-len(title_str)))
        bin_stl.write(b'\x0c')
        #Num Tria
        bin_stl.write(struct.pack('@L', int(facet_count)))
        for i in range(facet_count):
            for comp in range(3):
                bin_stl.write(struct.pack('<f', float(comp)))
            for vertex in faces[i]:
                for coord in vertex:
                    bin_stl.write(struct.pack('<f', float(coord)))
            bin_stl.write(struct.pack('@h', 0))

def refine_stl(faces):
    '''
    Increase the number of faces to 4x by creating the midpoint triangles.
    '''
    new_faces = []
    for face in faces:
        pt_A = face[0]
        pt_B = face[1]
        pt_C = face[2]
        
        midpt_AB = unit_vec(midpt(pt_A, pt_B))
        midpt_BC = unit_vec(midpt(pt_B, pt_C))
        midpt_CA = unit_vec(midpt(pt_C, pt_A))

        new_faces.append([pt_A, midpt_AB, midpt_CA])
        new_faces.append([pt_B, midpt_BC, midpt_AB])
        new_faces.append([pt_C, midpt_CA, midpt_BC])
        new_faces.append([midpt_AB, midpt_BC, midpt_CA])
    return new_faces

def area(faces):
    areas = []
    for face in faces:
        AB = [face[1][i]-face[0][i] for i in range(3)]
        AC = [face[2][i]-face[0][i] for i in range(3)]

        a = norm(cross_prod(AB,AC)) * 0.5
        areas.append(a)

    print(min(areas), max(areas))

def cross_prod(vec1, vec2):
    ans = [vec1[1]*vec2[2]-vec1[2]*vec2[1], vec1[2]*vec2[0]-vec1[0]*vec2[2], vec1[0]*vec2[1]-vec1[1]*vec2[0]]
    return ans

def norm(point):
    '''
    Find the length or the L2 norm of the vector.
    '''
    norm = 0
    for i in point:
        norm += i**2
    return norm**0.5

def unit_vec(point):
    '''
    Rescale the point, to find its projection on the surface of the unit sphere.
    '''
    mag = norm(point)
    pt = []
    for i in range(3):
        pt.append(point[i] / mag)
    return pt

def midpt(point1, point2):
    '''
Find the midpoint of the edge formed by the two points
    '''
    mid_point = []
    for i, pt in enumerate(point1):
        mid_point.append((pt + point2[i])/2)
    return mid_point

def conv_3_to_56(file_name, faces):
    '''
    Convert the Tria faced polyhedron into Hexagonal + 12 Pentagonal Faces
    '''

os.chdir('D:\Codes\Geometric')
n = int(input('Number of refinements:'))
name = 'IcoSphere_' + str(20*(4**n)) + '_faces.stl'
facelist = read_stl('Icosahedron.stl')
facelist_icosahedron = read_stl('Icosahedron.stl')
for i in range(n):
    area(facelist)
    facelist = refine_stl(facelist)
area(facelist)
save_stl(name, facelist)
conv_3_to_56(name, facelist)
